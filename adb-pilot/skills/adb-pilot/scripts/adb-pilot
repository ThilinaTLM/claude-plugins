#!/usr/bin/env python3
"""
adb-pilot - Unified Android testing tool with LLM-friendly JSON output.

Usage:
    adb-pilot info                          Device information
    adb-pilot screenshot [--clickable]      Screenshot + UI elements
    adb-pilot tap <x> <y>                   Tap at coordinates
    adb-pilot tap -t <text>                 Tap element by text
    adb-pilot swipe <up|down|left|right>    Swipe gesture
    adb-pilot type <text>                   Type into focused field
    adb-pilot key <name>                    Send key event
    adb-pilot wait <ms>                     Wait milliseconds
    adb-pilot hide-keyboard                 Dismiss keyboard
    adb-pilot clear                         Clear focused text field
    adb-pilot launch <package>              Launch app by package
    adb-pilot current                       Get current activity
    adb-pilot wait-for -t <text>            Wait for element to appear
    adb-pilot longpress <x> <y>             Long press at coordinates

All output is JSON for LLM consumption.
"""

import argparse
import json
import os
import re
import subprocess
import sys
import tempfile
import time
import xml.etree.ElementTree as ET
from datetime import datetime
from pathlib import Path
from typing import Any


def json_output(data: dict[str, Any]) -> None:
    """Print JSON output and exit."""
    print(json.dumps(data, separators=(",", ":")))


def json_ok(**kwargs: Any) -> None:
    """Print success JSON and exit."""
    json_output({"ok": True, **kwargs})
    sys.exit(0)


def json_error(error: str) -> None:
    """Print error JSON and exit."""
    json_output({"ok": False, "error": error})
    sys.exit(1)


class ADB:
    """Wrapper for ADB commands."""

    def __init__(self) -> None:
        self._device: str | None = None

    def run(self, *args: str, check: bool = True) -> subprocess.CompletedProcess:
        """Run an adb command."""
        cmd = ["adb", *args]
        try:
            return subprocess.run(cmd, capture_output=True, text=True, check=check)
        except FileNotFoundError:
            json_error("ADB not found. Please install Android SDK platform-tools.")
        except subprocess.CalledProcessError as e:
            json_error(f"ADB command failed: {e.stderr.strip()}")

    def shell(self, *args: str, check: bool = True) -> str:
        """Run an adb shell command and return stdout."""
        result = self.run("shell", *args, check=check)
        return result.stdout.strip().replace("\r", "")

    def pull(self, remote: str, local: str) -> None:
        """Pull a file from device."""
        self.run("pull", remote, local, check=False)

    def get_device(self) -> str:
        """Get connected device ID."""
        if self._device is not None:
            return self._device

        result = self.run("devices")
        lines = result.stdout.strip().split("\n")[1:]  # Skip header
        for line in lines:
            if "\tdevice" in line:
                self._device = line.split("\t")[0]
                return self._device

        json_error("No Android device connected. Run 'adb devices' to check.")

    def get_screen_size(self) -> tuple[int, int]:
        """Get screen dimensions."""
        output = self.shell("wm", "size")
        match = re.search(r"(\d+)x(\d+)", output)
        if match:
            return int(match.group(1)), int(match.group(2))
        json_error("Could not determine screen size.")


class UIElement:
    """Represents a UI element from the hierarchy."""

    def __init__(self, node: ET.Element) -> None:
        self.text = node.get("text", "")
        self.class_name = node.get("class", "").split(".")[-1]
        self.resource_id = node.get("resource-id", "").split("/")[-1] if "/" in node.get("resource-id", "") else node.get("resource-id", "")
        self.content_desc = node.get("content-desc", "")
        self.clickable = node.get("clickable", "false") == "true"
        self.bounds_str = node.get("bounds", "")

        # Parse bounds [x1,y1][x2,y2]
        self.x1 = self.y1 = self.x2 = self.y2 = 0
        self.x = self.y = 0

        match = re.match(r"\[(\d+),(\d+)\]\[(\d+),(\d+)\]", self.bounds_str)
        if match:
            self.x1, self.y1, self.x2, self.y2 = map(int, match.groups())
            self.x = (self.x1 + self.x2) // 2
            self.y = (self.y1 + self.y2) // 2

    def matches(self, query: str) -> bool:
        """Check if element matches a text query."""
        query_lower = query.lower()
        return (
            query_lower in self.text.lower()
            or query_lower in self.content_desc.lower()
            or query_lower in self.resource_id.lower()
        )

    def is_empty(self) -> bool:
        """Check if element has no identifying information."""
        return not self.text and not self.resource_id and not self.content_desc

    def is_input_field(self) -> bool:
        """Check if element is an input field."""
        return self.class_name in ("EditText", "TextInputEditText", "AutoCompleteTextView")

    def to_dict(self) -> dict[str, Any]:
        """Convert to dictionary for JSON output."""
        return {
            "text": self.text,
            "class": self.class_name,
            "id": self.resource_id,
            "desc": self.content_desc,
            "clickable": self.clickable,
            "x": self.x,
            "y": self.y,
            "bounds": [self.x1, self.y1, self.x2, self.y2],
        }


def dump_ui_hierarchy(adb: ADB, max_retries: int = 3) -> list[UIElement]:
    """Dump and parse UI hierarchy with retry logic for Android 14+."""
    remote_path = "/sdcard/ui_dump.xml"

    # Try uiautomator dump with retries (helps with "could not get idle state" on newer Android)
    for attempt in range(max_retries):
        result = adb.run("shell", "uiautomator", "dump", remote_path, check=False)
        output = result.stdout + result.stderr

        if "ERROR" not in output:
            break

        # Wait before retry - UI might not be idle
        if attempt < max_retries - 1:
            time.sleep(0.5)
    else:
        # All retries failed
        return []

    # Pull to temp file
    with tempfile.NamedTemporaryFile(suffix=".xml", delete=False) as f:
        local_path = f.name

    try:
        adb.pull(remote_path, local_path)
        adb.shell("rm", remote_path, check=False)

        if not os.path.exists(local_path) or os.path.getsize(local_path) == 0:
            return []

        # Parse XML
        tree = ET.parse(local_path)
        root = tree.getroot()

        elements = []
        for node in root.iter("node"):
            elem = UIElement(node)
            if not elem.is_empty():
                elements.append(elem)

        return elements
    except ET.ParseError:
        return []
    finally:
        if os.path.exists(local_path):
            os.unlink(local_path)


# Key name to keycode mapping
KEY_CODES = {
    # Navigation keys (affect app/system)
    "back": 4,
    "app_home": 3,       # KEYCODE_HOME - goes to Android home screen
    "home": 3,           # Legacy alias (use app_home for clarity)
    "menu": 82,
    "search": 84,

    # Text editing keys
    "enter": 66,
    "tab": 61,
    "delete": 67,
    "del": 67,
    "space": 62,

    # Cursor movement keys (for text fields)
    "move_home": 122,    # KEYCODE_MOVE_HOME - cursor to start of line
    "move_end": 123,     # KEYCODE_MOVE_END - cursor to end of line
    "page_up": 92,       # KEYCODE_PAGE_UP
    "page_down": 93,     # KEYCODE_PAGE_DOWN

    # D-pad / arrow keys
    "up": 19,
    "down": 20,
    "left": 21,
    "right": 22,

    # Volume/power
    "volup": 24,
    "voldown": 25,
    "power": 26,

    # Escape
    "escape": 111,
    "esc": 111,
}


def cmd_info(args: argparse.Namespace) -> None:
    """Get device information."""
    adb = ADB()
    device = adb.get_device()

    model = adb.shell("getprop", "ro.product.model")
    brand = adb.shell("getprop", "ro.product.brand")
    android = adb.shell("getprop", "ro.build.version.release")
    sdk = adb.shell("getprop", "ro.build.version.sdk")
    width, height = adb.get_screen_size()
    density = adb.shell("wm", "density").split()[-1]

    json_ok(
        device=device,
        model=model,
        brand=brand,
        android=android,
        sdk=sdk,
        width=width,
        height=height,
        density=int(density) if density.isdigit() else 0,
    )


def cmd_screenshot(args: argparse.Namespace) -> None:
    """Take screenshot and dump UI elements."""
    adb = ADB()
    adb.get_device()

    output_dir = Path(args.dir) if args.dir else Path(tempfile.gettempdir())
    output_dir.mkdir(parents=True, exist_ok=True)

    # Take screenshot
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    screenshot_file = output_dir / f"screenshot_{timestamp}.png"
    remote_screenshot = "/sdcard/screenshot.png"

    adb.shell("screencap", "-p", remote_screenshot)
    adb.pull(remote_screenshot, str(screenshot_file))
    adb.shell("rm", remote_screenshot, check=False)

    # Dump UI hierarchy (skip if --no-ui)
    elements: list[UIElement] = []
    if not args.no_ui:
        elements = dump_ui_hierarchy(adb)

        # Apply filters
        if args.clickable:
            elements = [e for e in elements if e.clickable]

        if args.text:
            elements = [e for e in elements if e.matches(args.text)]

    json_ok(
        screenshot=str(screenshot_file),
        elements=[e.to_dict() for e in elements],
    )


def cmd_tap(args: argparse.Namespace) -> None:
    """Tap at coordinates or by text."""
    adb = ADB()
    adb.get_device()

    x, y = None, None
    matched_text = None

    if args.text:
        # Find element by text
        elements = dump_ui_hierarchy(adb)
        matches = [e for e in elements if e.matches(args.text)]

        if not matches:
            json_error(f"No element found matching '{args.text}'")

        # If --prefer-input, sort to put input fields first
        if getattr(args, 'prefer_input', False):
            matches.sort(key=lambda e: (not e.is_input_field(), e.y))

        # If --clickable, filter to clickable elements only
        if getattr(args, 'clickable_only', False):
            matches = [e for e in matches if e.clickable]
            if not matches:
                json_error(f"No clickable element found matching '{args.text}'")

        if args.index >= len(matches):
            json_error(f"Index {args.index} out of range (found {len(matches)} matches)")

        elem = matches[args.index]
        x, y = elem.x, elem.y
        matched_text = elem.text or elem.content_desc or elem.resource_id
    elif args.x is not None and args.y is not None:
        x, y = args.x, args.y
    else:
        json_error("Specify coordinates (tap X Y) or text (tap -t TEXT)")

    # Perform tap
    adb.shell("input", "tap", str(x), str(y))

    # Wait if specified
    if args.wait:
        time.sleep(args.wait / 1000)

    result = {"action": "tap", "x": x, "y": y}
    if matched_text:
        result["matched"] = matched_text

    json_ok(**result)


def cmd_swipe(args: argparse.Namespace) -> None:
    """Swipe gesture."""
    adb = ADB()
    adb.get_device()

    width, height = adb.get_screen_size()
    cx, cy = width // 2, height // 2
    duration = args.duration

    direction = args.direction
    if direction == "up":
        start_x, start_y = cx, height * 3 // 4
        end_x, end_y = cx, height // 4
    elif direction == "down":
        start_x, start_y = cx, height // 4
        end_x, end_y = cx, height * 3 // 4
    elif direction == "left":
        start_x, start_y = width * 3 // 4, cy
        end_x, end_y = width // 4, cy
    elif direction == "right":
        start_x, start_y = width // 4, cy
        end_x, end_y = width * 3 // 4, cy
    else:
        json_error(f"Invalid direction: {direction}")

    adb.shell("input", "swipe", str(start_x), str(start_y), str(end_x), str(end_y), str(duration))

    if args.wait:
        time.sleep(args.wait / 1000)

    json_ok(action="swipe", direction=direction)


def cmd_type(args: argparse.Namespace) -> None:
    """Type text into focused field."""
    adb = ADB()
    adb.get_device()

    # Escape text for adb: replace spaces with %s
    escaped = args.text.replace(" ", "%s")
    adb.shell("input", "text", escaped)

    if args.wait:
        time.sleep(args.wait / 1000)

    json_ok(action="type", text=args.text)


def cmd_key(args: argparse.Namespace) -> None:
    """Send key event."""
    adb = ADB()
    adb.get_device()

    key = args.key.lower()
    if key in KEY_CODES:
        keycode = KEY_CODES[key]
    elif key.isdigit():
        keycode = int(key)
    else:
        json_error(f"Unknown key: {key}. Available: {', '.join(KEY_CODES.keys())}")

    adb.shell("input", "keyevent", str(keycode))

    if args.wait:
        time.sleep(args.wait / 1000)

    json_ok(action="key", key=args.key, keycode=keycode)


def cmd_wait(args: argparse.Namespace) -> None:
    """Wait for specified milliseconds."""
    time.sleep(args.ms / 1000)
    json_ok(action="wait", ms=args.ms)


def cmd_hide_keyboard(args: argparse.Namespace) -> None:
    """Dismiss the on-screen keyboard."""
    adb = ADB()
    adb.get_device()

    # Send ESCAPE key to dismiss keyboard without navigating back
    adb.shell("input", "keyevent", "111")

    if args.wait:
        time.sleep(args.wait / 1000)

    json_ok(action="hide_keyboard")


def cmd_clear(args: argparse.Namespace) -> None:
    """Clear the currently focused text field."""
    adb = ADB()
    adb.get_device()

    # Move cursor to end of text first
    adb.shell("input", "keyevent", "123")  # KEYCODE_MOVE_END
    time.sleep(0.05)

    # Delete all characters by sending multiple backspace keys
    # Most text fields are < 200 chars, send 200 deletes to be safe
    # We batch them in groups for efficiency
    for _ in range(20):
        # Send 10 delete keys per batch
        adb.shell("input", "keyevent", "67", "67", "67", "67", "67", "67", "67", "67", "67", "67")

    if args.wait:
        time.sleep(args.wait / 1000)

    json_ok(action="clear")


def cmd_fill(args: argparse.Namespace) -> None:
    """Fill a text field: tap, clear, type, then hide keyboard."""
    adb = ADB()
    adb.get_device()

    # Find the element
    elements = dump_ui_hierarchy(adb)
    matches = [e for e in elements if e.matches(args.field)]

    if not matches:
        json_error(f"No element found matching '{args.field}'")

    # Sort to prefer input fields
    matches.sort(key=lambda e: (not e.is_input_field(), e.y))
    elem = matches[0]

    # Tap the element
    adb.shell("input", "tap", str(elem.x), str(elem.y))
    time.sleep(0.3)

    # Clear (move to end, then delete all)
    adb.shell("input", "keyevent", "123")  # KEYCODE_MOVE_END
    time.sleep(0.05)
    for _ in range(20):
        adb.shell("input", "keyevent", "67", "67", "67", "67", "67", "67", "67", "67", "67", "67")

    # Type the value
    escaped = args.value.replace(" ", "%s")
    adb.shell("input", "text", escaped)
    time.sleep(0.1)

    # Hide keyboard
    adb.shell("input", "keyevent", "111")  # ESCAPE

    if args.wait:
        time.sleep(args.wait / 1000)

    json_ok(
        action="fill",
        field=args.field,
        value=args.value,
        x=elem.x,
        y=elem.y,
        matched=elem.text or elem.content_desc or elem.resource_id
    )


def cmd_select_all(args: argparse.Namespace) -> None:
    """Select all text in the currently focused field using Ctrl+A."""
    adb = ADB()
    adb.get_device()

    # Try Ctrl+A using keyevent with meta modifier flag
    # META_CTRL_ON = 0x1000 (4096 decimal)
    # This should work on Android 11+
    # Format: input keyevent --meta <meta_state> <keycode>
    result = adb.shell("input", "keyevent", "--meta", "4096", "29", check=False)

    # If that failed (older Android), fall back to sequential approach
    if "Unknown" in result or "error" in result.lower():
        # Try the sequential key press (less reliable but worth trying)
        adb.shell("input", "keyevent", "113")  # CTRL_LEFT down
        adb.shell("input", "keyevent", "29")   # A
        adb.shell("input", "keyevent", "113")  # CTRL_LEFT up

    if args.wait:
        time.sleep(args.wait / 1000)

    json_ok(action="select_all")


def cmd_launch(args: argparse.Namespace) -> None:
    """Launch an app by package name."""
    adb = ADB()
    adb.get_device()

    # Use monkey to launch the app's main activity
    result = adb.shell(
        "monkey", "-p", args.package,
        "-c", "android.intent.category.LAUNCHER", "1",
        check=False
    )

    if "No activities found" in result:
        json_error(f"No launchable activity found for package: {args.package}")

    if args.wait:
        time.sleep(args.wait / 1000)

    json_ok(action="launch", package=args.package)


def cmd_current(args: argparse.Namespace) -> None:
    """Get the currently visible activity."""
    adb = ADB()
    adb.get_device()

    # Get the resumed activity from dumpsys
    output = adb.shell("dumpsys", "activity", "activities")

    # Parse mResumedActivity line
    activity = None
    package = None
    for line in output.split("\n"):
        if "mResumedActivity" in line or "topResumedActivity" in line:
            # Format: mResumedActivity: ActivityRecord{...  com.example.app/.MainActivity ...}
            match = re.search(r"(\S+)/(\S+)", line)
            if match:
                package = match.group(1)
                activity_name = match.group(2)
                activity = f"{package}/{activity_name}"
                break

    if not activity:
        json_error("Could not determine current activity")

    json_ok(action="current", activity=activity, package=package)


def cmd_wait_for(args: argparse.Namespace) -> None:
    """Wait for an element to appear on screen."""
    adb = ADB()
    adb.get_device()

    timeout_ms = args.timeout * 1000 if args.timeout else 10000
    poll_interval = 0.25  # Reduced from 0.5s for faster detection
    start = time.time()

    while (time.time() - start) * 1000 < timeout_ms:
        elements = dump_ui_hierarchy(adb)
        matches = [e for e in elements if e.matches(args.text)]

        if matches:
            elem = matches[0]
            json_ok(
                action="wait_for",
                found=True,
                element=elem.to_dict(),
                elapsed_ms=int((time.time() - start) * 1000)
            )

        time.sleep(poll_interval)

    # Timeout - include searched text for debugging
    json_ok(
        action="wait_for",
        found=False,
        timeout=True,
        searched=args.text,
        elapsed_ms=int((time.time() - start) * 1000)
    )


def cmd_longpress(args: argparse.Namespace) -> None:
    """Long press at coordinates or by text."""
    adb = ADB()
    adb.get_device()

    x, y = None, None
    matched_text = None

    if args.text:
        # Find element by text
        elements = dump_ui_hierarchy(adb)
        matches = [e for e in elements if e.matches(args.text)]

        if not matches:
            json_error(f"No element found matching '{args.text}'")

        if args.index >= len(matches):
            json_error(f"Index {args.index} out of range (found {len(matches)} matches)")

        elem = matches[args.index]
        x, y = elem.x, elem.y
        matched_text = elem.text or elem.content_desc or elem.resource_id
    elif args.x is not None and args.y is not None:
        x, y = args.x, args.y
    else:
        json_error("Specify coordinates (longpress X Y) or text (longpress -t TEXT)")

    # Long press = swipe from same point to same point with long duration
    duration = args.duration if args.duration else 1000
    adb.shell("input", "swipe", str(x), str(y), str(x), str(y), str(duration))

    if args.wait:
        time.sleep(args.wait / 1000)

    result = {"action": "longpress", "x": x, "y": y, "duration": duration}
    if matched_text:
        result["matched"] = matched_text

    json_ok(**result)


def main() -> None:
    parser = argparse.ArgumentParser(
        description="Unified Android testing tool with JSON output",
        formatter_class=argparse.RawDescriptionHelpFormatter,
    )
    subparsers = parser.add_subparsers(dest="command", required=True)

    # info
    subparsers.add_parser("info", help="Device information")

    # screenshot
    p_screenshot = subparsers.add_parser("screenshot", aliases=["ss", "screen"], help="Screenshot + UI elements")
    p_screenshot.add_argument("-c", "--clickable", action="store_true", help="Only clickable elements")
    p_screenshot.add_argument("-t", "--text", help="Filter by text")
    p_screenshot.add_argument("-d", "--dir", default=None, help="Output directory (default: system temp)")
    p_screenshot.add_argument("--no-ui", action="store_true", help="Skip UI hierarchy dump for faster capture")

    # tap
    p_tap = subparsers.add_parser("tap", aliases=["click"], help="Tap at coordinates or by text")
    p_tap.add_argument("x", type=int, nargs="?", help="X coordinate")
    p_tap.add_argument("y", type=int, nargs="?", help="Y coordinate")
    p_tap.add_argument("-t", "--text", help="Find and tap element by text")
    p_tap.add_argument("-i", "--index", type=int, default=0, help="Index if multiple matches")
    p_tap.add_argument("-w", "--wait", type=int, help="Wait ms after tap")
    p_tap.add_argument("--prefer-input", action="store_true", help="Prefer input fields over labels")
    p_tap.add_argument("--clickable", action="store_true", dest="clickable_only", help="Only match clickable elements")

    # swipe
    p_swipe = subparsers.add_parser("swipe", aliases=["scroll"], help="Swipe gesture")
    p_swipe.add_argument("direction", choices=["up", "down", "left", "right"], help="Swipe direction")
    p_swipe.add_argument("-d", "--duration", type=int, default=300, help="Swipe duration in ms")
    p_swipe.add_argument("-w", "--wait", type=int, help="Wait ms after swipe")

    # type
    p_type = subparsers.add_parser("type", aliases=["text", "input"], help="Type text")
    p_type.add_argument("text", help="Text to type")
    p_type.add_argument("-w", "--wait", type=int, help="Wait ms after typing")

    # key
    p_key = subparsers.add_parser("key", aliases=["keyevent"], help="Send key event")
    p_key.add_argument("key", help="Key name or code")
    p_key.add_argument("-w", "--wait", type=int, help="Wait ms after key")

    # wait
    p_wait = subparsers.add_parser("wait", aliases=["sleep"], help="Wait milliseconds")
    p_wait.add_argument("ms", type=int, help="Milliseconds to wait")

    # hide-keyboard
    p_hide_kb = subparsers.add_parser("hide-keyboard", aliases=["hidekb", "dismiss-keyboard"], help="Dismiss keyboard")
    p_hide_kb.add_argument("-w", "--wait", type=int, help="Wait ms after action")

    # clear
    p_clear = subparsers.add_parser("clear", aliases=["clear-field"], help="Clear focused text field")
    p_clear.add_argument("-w", "--wait", type=int, help="Wait ms after action")

    # fill
    p_fill = subparsers.add_parser("fill", help="Fill a text field (tap + clear + type + hide-keyboard)")
    p_fill.add_argument("field", help="Field text to find")
    p_fill.add_argument("value", help="Value to type")
    p_fill.add_argument("-w", "--wait", type=int, help="Wait ms after action")

    # select-all
    p_select_all = subparsers.add_parser("select-all", aliases=["selectall", "select"], help="Select all text in field")
    p_select_all.add_argument("-w", "--wait", type=int, help="Wait ms after action")

    # launch
    p_launch = subparsers.add_parser("launch", aliases=["start", "open"], help="Launch app by package name")
    p_launch.add_argument("package", help="Package name (e.g., com.example.app)")
    p_launch.add_argument("-w", "--wait", type=int, help="Wait ms after launch")

    # current
    subparsers.add_parser("current", aliases=["activity", "foreground"], help="Get current activity")

    # wait-for
    p_wait_for = subparsers.add_parser("wait-for", aliases=["waitfor", "await"], help="Wait for element to appear")
    p_wait_for.add_argument("-t", "--text", required=True, help="Text to wait for")
    p_wait_for.add_argument("-s", "--timeout", type=int, default=10, help="Timeout in seconds (default: 10)")

    # longpress
    p_longpress = subparsers.add_parser("longpress", aliases=["hold", "long-press"], help="Long press")
    p_longpress.add_argument("x", type=int, nargs="?", help="X coordinate")
    p_longpress.add_argument("y", type=int, nargs="?", help="Y coordinate")
    p_longpress.add_argument("-t", "--text", help="Find and long press element by text")
    p_longpress.add_argument("-i", "--index", type=int, default=0, help="Index if multiple matches")
    p_longpress.add_argument("-d", "--duration", type=int, default=1000, help="Press duration in ms (default: 1000)")
    p_longpress.add_argument("-w", "--wait", type=int, help="Wait ms after action")

    args = parser.parse_args()

    # Dispatch to command handler
    handlers = {
        "info": cmd_info,
        "screenshot": cmd_screenshot,
        "ss": cmd_screenshot,
        "screen": cmd_screenshot,
        "tap": cmd_tap,
        "click": cmd_tap,
        "swipe": cmd_swipe,
        "scroll": cmd_swipe,
        "type": cmd_type,
        "text": cmd_type,
        "input": cmd_type,
        "key": cmd_key,
        "keyevent": cmd_key,
        "wait": cmd_wait,
        "sleep": cmd_wait,
        "hide-keyboard": cmd_hide_keyboard,
        "hidekb": cmd_hide_keyboard,
        "dismiss-keyboard": cmd_hide_keyboard,
        "clear": cmd_clear,
        "clear-field": cmd_clear,
        "fill": cmd_fill,
        "select-all": cmd_select_all,
        "selectall": cmd_select_all,
        "select": cmd_select_all,
        "launch": cmd_launch,
        "start": cmd_launch,
        "open": cmd_launch,
        "current": cmd_current,
        "activity": cmd_current,
        "foreground": cmd_current,
        "wait-for": cmd_wait_for,
        "waitfor": cmd_wait_for,
        "await": cmd_wait_for,
        "longpress": cmd_longpress,
        "hold": cmd_longpress,
        "long-press": cmd_longpress,
    }

    handler = handlers.get(args.command)
    if handler:
        handler(args)
    else:
        json_error(f"Unknown command: {args.command}")


if __name__ == "__main__":
    main()
